// 동적 계획법

// Dynamic Programming

// 큰 문제가 있다고 했을 때, 한 번에 풀기는 너무 복잡하고 거대하니까 작은 단위로 쪼개는 것.
// -> 직관적으로 알 수 있는 최소한의 단위의 문제로 쪼개서 답을 구하고, 이 답을 기록해둔 뒤에 범위를 약간 더 넓혀서 다음 문제의 답을 기존에 구했던 작은 범위의 답을 이용해서 구하는 것. ( 점화식 형태 )

// 점화식을 만들어내는 것이 포인트

// 계단을 1개 or 2개씩 올라갈 수 있을 때, 총 N개의 계단을 올라가는 경우의 수는?

// 작은 문제부터 해결하고 해답을 기록한 후에 경향성을 찾아서 다음 문제를 해결하는 실마리로 삼아보자
// 1번 계단을 올라가는 경우의 수? -> 1가지
// 2번 계단을 올라가는 경우의 수? -> 2가지.
// 3번 계단을 올라가는 경우의 수? -> 3가지
// 그런데, 3에 도착할려면 어디에서 와야하는가? 1에서 오거나 2에서 오거나 둘 중 하나일 뿐이다.
// 즉 1번에서 2개를 올라가거나(1개 2번 or 2개 1번)
// 2번에서 1개를 올라가거나 (1개 1번)

// 즉 n번째 계단까지 가는 방법은,
// n-2 번째 계단까지 가는 방법 + n-1번째계단까지 가는 방법

// 간단해보이지만, 이 규칙성을 명확하게 찾아내는 것이 쉬운 일이 아니라는 점

function solution(n) {
  let answer = 0;

  const solutions = Array(n + 1).fill(0); // 직관적으로 1번째 계단 -> 1번째 인덱스 로 처리

  solutions[1] = 1;
  solutions[2] = 2;

  for (let i = 3; i <= n; i++) {
    solutions[i] = solutions[i - 2] + solutions[i - 1];
  }

  answer = solutions[n];

  return answer;
}

console.log(solution(7)); // 21

// 이해가 안되는 부분이 있었는데, 이해가 됨
// 1 -> 3가는 방법은 2가지이지만, 1에서 3으로 한 번에 가는 방법은 한 가지 뿐. 즉 direct 하게 갈 수 잇는 방법을 택하면 된다.
