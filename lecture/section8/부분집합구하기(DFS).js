// 부분집합 구하기

// DFS

// 아직 잘 모르겠다...

// 전체 집합이 {1,2,3} 이면, 부분집합은 2^3 = 8 (공집합 포함)
// 각 요소에 대해서 포함된다/포함되지 않는다 2 가지 케이스가 존재할 수 있으므로 모든 조합을 구하면 2^3

// 어떤 느낌에서 이게 트리 구조가 되는 것일까?

// 1에 대해서 먼저 분기 (1이 루트노드라고 보는 것)

// 자식 노드 2개 ( 포함되는 경우 / 포함되지 않는 경우)
// 각각 자식 노드에 대해서 2를 가지고 분기
// 포함되는 경우에 대해서 2가 포함되는 경우 / 포함되지 않는 경우
// 포함되지 않는 경우에 대해서 2가 포함되는 경우 / 포함되지 않는 경우
// 즉 각 자식 노드에 대해서 또 2가지 선택지(2개의 자식 노드)가 존재하게 된다.
// 그리고 2레벨의 총 4개의 자식 노드에 대해서 3이 포함되는 경우 / 포함되지 않는 경우 2가지 자식 노드가 생기므로 총 8개의 노드가 생성된다. ( 3레벨 ) -> 이진트리 형태로 볼 수 있다.

// 이제 이정도 힌트를 가지고 문제를 어떻게 풀어야할지 한 번 고민해보자.

// 루트 노드에서 시작 -> 재귀함수 형태로 풀어본다고 치면, 자식 노드로 퍼지면서 재귀적으로 함수를 실행하고 어떤 조건에서 종료되어야 하는지 생각하면 된다.

// function solution_1(n) {
//   // n기준 종료시점까지 실행되는 재귀함수가 필요해
//   function DFS(v, includeState, prevArray) {
//     if (v > n) return; // 종료조건, n 까지에대해서만 포함 비포함 처리되어야 한다.
//     if (includeState) {
//       // 포함조건이면 추가하고 찍고, 넘긴다.
//       prevArray.push(v);
//       console.log(prevArray);
//       DFS(v + 1, true, prevArray);
//       DFS(v + 1, false, prevArray);
//     } else {
//       DFS(v + 1, true, prevArray);
//       DFS(v + 1, false, prevArray);
//     }
//   }

//   // v+1 이 자식 노드 레벨이고, 자식 노드는 포함/비포함 상태에 따라 다르게 처리되어야 한다.
//   DFS(1, true, []);
//   DFS(1, false, []);
// }

// solution_1(3);

function lecture_solution(n) {
  let visited = Array(n + 1).fill(0);

  // console.log(visited); // [0, 0, 0, 0]
  // 해당 배열의 인덱스 값이 해당 인덱스가 포함되어있는지 아닌지 담는 변수 역할(1 === 포함, 0 === 미포함)

  function DFS(v) {
    if (v === n + 1) {
      const partArr = [];

      for (let i = 1; i <= n; i++) {
        if (visited[i] === 1) partArr.push(i);
      }

      if (partArr.length !== 0) console.log(partArr);
    } else {
      visited[v] = 1;
      DFS(v + 1);

      visited[v] = 0;
      DFS(v + 1);
    }
  }

  DFS(1);

  console.log("completed");
}

lecture_solution(3);

// 로직 실행 순서
// DFS(1) 실행

// v = 4 인 케이스는 그 때에 대해서만 처리하겠음

// [0, 1, 0, 0] 에 대해서 처리 - 1-1
//// DFS(2) 실행
//// [0, 1, 1, 0] 에 대해서 처리 - 1-1-2-1
////// DFS(3) 실행
////// [0,1,1,1] 에 대해서 처리 - 1-1-2-1-3-1
//////// DFS(4) 실행
/////// 1,2,3 출력

////// DFS(3) 실행
////// [0,1,1,0] 에 대해서 처리 - 1-1-2-1-3-2
//////// DFS(4) 실행
//////// 1,2 출력

//// [0, 1, 0, 0] 에 대해서 처리 - 1-1-2-2
////// DFS(3) 실행
////// [0, 1, 0, 1] 에 대해서 처리 - 1-1-2-2-3-1
//////// DFS(4) 실행
//////// 1, 3 출력
////// [0, 1, 0, 0] 에 대해서 처리 - 1-1-2-2-3-2
//////// DFS(4) 실행
//////// 1 출력

// [0, 0, 0, 0]에 대해서 처리 - 1-2
// 위와 같은 처리가 이루어 진다.

// 아하

// take away 가 무엇인지?
// 1. 상태 저장은 배열로 처리한다(각 단계별 상태를 0,1 로 처리해서 상태를 확인함)
// 2. 로직 처리 순서를 알고 있는 것이 중요하다. 같은 배열을 여러번 조작하는 형태로 구현하기 때문에 값 처리가 명확하게 되어야 한다.
